<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chart Demo</title>
  <style>
    #metrics-box {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #f0f0f0;
      padding: 10px;
      border: 1px solid #ccc;
      font-family: Arial, sans-serif;
    }
    #connection-status {
      position: fixed;
      bottom: 10px;
      right: 10px;
    }
  </style>
</head>
<body>
  <div id="metrics-box">
    OI: 0 BTC<br>
    CVD: 0 BTC<br>
    Long LIQ: $0<br>
    Short LIQ: $0
  </div>
  <div id="connection-status">Disconnected</div>

  <script>
    // WebSocket connections
    const bybitWs = new WebSocket('wss://stream.bybit.com/v5/public/spot');
    const krakenWs = new WebSocket('wss://ws.kraken.com');

    // Metrics variables
    let cumulativeVolumeDelta = 0;
    let liveOiBtc = 0;
    let lastBtcPrice = 0;
    let longPressure = 0;
    let shortPressure = 0;
    const LIQ_SENSITIVITY = 100;
    const PRESSURE_DECAY = 0.95;
    let lastPressureUpdate = Date.now();
    const liquidationCandles = {};

    // Bybit WebSocket
    bybitWs.onopen = () => {
      console.log('Bybit WebSocket connected');
      bybitWs.send(JSON.stringify({
        op: 'subscribe',
        args: ['publicTrade.BTCUSDT', 'liquidation.BTCUSDT']
      }));
      updateConnectionStatus('Connected');
    };

    bybitWs.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log(`Raw Bybit message:`, message);

      if (message.topic === 'publicTrade.BTCUSDT') {
        message.data.forEach(trade => {
          const timestamp = Math.floor(trade.ts / 1000);
          const volume = parseFloat(trade.v) / lastBtcPrice; // Convert to BTC
          const side = trade.S === 'Buy' ? 1 : -1;
          processTradeForCvd({ timestamp, volume, side });
        });
      } else if (message.topic === 'liquidation.BTCUSDT') {
        const data = message.data;
        console.log('Full liquidation data:', data);
        const timestamp = Math.floor(data.updatedTime / 1000);
        const liqValue = parseFloat(data.size);
        const side = data.side; // 'Buy' or 'Sell'
        console.log('Processing liquidation:', { timestamp, liqValue, side });
        updateLiqCandle({ timestamp, liqValue, side });
      }
    };

    bybitWs.onerror = (error) => console.error('Bybit WS Error:', error);
    bybitWs.onclose = () => {
      console.log('Bybit WebSocket closed');
      updateConnectionStatus('Disconnected');
    };

    // Kraken WebSocket
    krakenWs.onopen = () => {
      console.log('Kraken WebSocket connected');
      krakenWs.send(JSON.stringify({
        event: 'subscribe',
        pair: ['XBT/USD'],
        subscription: { name: 'trade' }
      }));
    };

    krakenWs.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (Array.isArray(data) && data[2] === 'trade') {
        console.log('Raw Kraken trade:', data);
        const trades = data[1];
        trades.forEach(trade => {
          const price = parseFloat(trade[0]);
          lastBtcPrice = price; // Update last price
          console.log('Live trade update:', { price, bar: {} });
        });
      }
    };

    krakenWs.onerror = (error) => console.error('Kraken WS Error:', error);
    krakenWs.onclose = () => console.log('Kraken WebSocket closed');

    // Binance OI Fetching
    function fetchBinanceOi() {
      const url = 'https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT';
      console.log('Fetching live Binance OI:', url);
      fetch(url)
        .then(response => response.json())
        .then(data => {
          console.log('Live Binance OI response:', data);
          liveOiBtc = parseFloat(data.openInterest) * 0.001; // Adjust as needed
          updateConnectionStatus('Connected');
          updateMetricsBox();
        })
        .catch(error => console.error('Binance OI Fetch Error:', error));
    }
    setInterval(fetchBinanceOi, 5000); // Fetch every 5s
    fetchBinanceOi(); // Initial fetch

    // Processing Functions
    function processTradeForCvd({ timestamp, volume, side }) {
      console.log('Processing trade for CVD:', { timestamp, volume, side });
      cumulativeVolumeDelta += volume * side;
      updateMetricsBox();
    }

    function updateLiqCandle({ timestamp, liqValue, side }) {
      const now = Date.now();
      const timeElapsed = (now - lastPressureUpdate) / 60000; // Minutes
      lastPressureUpdate = now;

      // Apply decay
      longPressure *= Math.pow(PRESSURE_DECAY, timeElapsed);
      shortPressure *= Math.pow(PRESSURE_DECAY, timeElapsed);

      const adjustedValue = liqValue * LIQ_SENSITIVITY;
      const delta = adjustedValue;
      const prevLongPressure = longPressure;
      const prevShortPressure = shortPressure;

      if (side === 'Buy') {
        longPressure += delta; // Longs liquidated
      } else if (side === 'Sell') {
        shortPressure += delta; // Shorts liquidated
      }

      console.log(`LIQ Update - Timestamp: ${timestamp}, BTC: ${liqValue}, Side: ${side}, ` +
                  `Long Delta: ${side === 'Buy' ? delta : 0}, Short Delta: ${side === 'Sell' ? delta : 0}, ` +
                  `Prev Long: ${prevLongPressure}, Prev Short: ${prevShortPressure}, ` +
                  `New Long: ${longPressure}, New Short: ${shortPressure}, Price: $${lastBtcPrice}`);

      // Optional: Keep candle for charting (net pressure)
      const candleTime = Math.floor(timestamp / 60) * 60;
      const liqCandle = liquidationCandles[candleTime] || { time: candleTime, open: 0, high: 0, low: 0, close: 0 };
      liqCandle.close = longPressure - shortPressure;
      liqCandle.high = Math.max(liqCandle.high, liqCandle.close);
      liqCandle.low = Math.min(liqCandle.low, liqCandle.close);
      liquidationCandles[candleTime] = liqCandle;

      updateMetricsBox();
    }

    function updateMetricsBox() {
      const longBtc = longPressure / LIQ_SENSITIVITY;
      const shortBtc = shortPressure / LIQ_SENSITIVITY;
      const longDollarValue = formatDollar(longBtc * lastBtcPrice);
      const shortDollarValue = formatDollar(shortBtc * lastBtcPrice);

      const metricsBox = document.getElementById('metrics-box');
      metricsBox.innerHTML = `
        OI: ${formatBtc(liveOiBtc)} BTC<br>
        CVD: ${formatBtc(cumulativeVolumeDelta)} BTC<br>
        Long LIQ: ${longDollarValue}<br>
        Short LIQ: ${shortDollarValue}
      `;
    }

    // Formatting Helpers
    function formatBtc(value) {
      return value.toFixed(3);
    }

    function formatDollar(value) {
      const rounded = Math.round(value / 10000) * 10000;
      return rounded >= 0 ? `$${rounded.toLocaleString()}` : `-$${Math.abs(rounded).toLocaleString()}`;
    }

    function updateConnectionStatus(status) {
      document.getElementById('connection-status').textContent = status;
      console.log('Connection status updated:', status);
    }
  </script>
</body>
</html>
