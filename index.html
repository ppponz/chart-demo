<!DOCTYPE html>
<html lang="en">
<head>
    <title>BTC Price, Liquidations, CVD, and OI</title>
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow-x: hidden; font-family: 'Arial', sans-serif; background-color: #0d1117; color: #D3D3D3; }
        #container { max-width: 1400px; margin: 10px auto; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
        #title-box { display: flex; justify-content: space-between; align-items: center; padding: 5px; background: #161b22; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); }
        #metrics-table { flex: 1; text-align: center; }
        #metrics-table table { width: 100%; border-collapse: collapse; }
        #metrics-table th { padding: 4px; font-size: 0.9em; color: #D3D3D3; background: #1c2526; }
        #metrics-table td { padding: 4px; font-size: 1.2em; color: #D3D3D3; text-align: center; }
        #connection-status { padding: 5px 10px; font-size: 0.9em; color: #888888; }
        #price-chart { height: 300px; background-color: #161b22; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); overflow: hidden; }
        .chart-wrapper { height: 100px; background-color: #161b22; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); overflow: hidden; }
        #loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        #loading-text { color: #888888; font-size: 1.2em; }
        .negative { color: #ff5555; }
        .positive { color: #00ffff; }
        .disconnected { color: #ef5350; }
    </style>
</head>
<body>
    <div id="loading-overlay"><div id="loading-text">Loading historical price data...</div></div>
    <div id="container">
        <div id="title-box">
            <div id="metrics-table">
                <table>
                    <thead><tr><th>CVD</th><th>OI</th><th>Long LIQ</th><th>Short LIQ</th></tr></thead>
                    <tbody><tr><td id="cvd-data">0</td><td id="oi-data">0</td><td id="long-liq-data">0</td><td id="short-liq-data">0</td></tr></tbody>
                </table>
            </div>
            <div id="connection-status">Connecting...</div>
        </div>
        <div id="price-chart"></div>
        <div id="cvd-chart" class="chart-wrapper"></div>
        <div id="oi-chart" class="chart-wrapper"></div>
        <div id="liq-chart" class="chart-wrapper"></div>
    </div>
    <script>
        (async () => {
            if (!window.LightweightCharts) {
                console.error('LightweightCharts v4.0.1 failed to load');
                return;
            }

            // Configuration
            const CONFIG = {
                urls: {
                    krakenWs: 'wss://ws.kraken.com',
                    bybitWs: 'wss://stream.bybit.com/v5/public/linear',
                    krakenOhlc: 'https://api.kraken.com/0/public/OHLC',
                    binanceOi: 'https://fapi.binance.com/fapi/v1/openInterest'
                },
                time: {
                    historyDays: 0.5, // 12 hours
                    barInterval: 30,
                    maxBars: 1440,
                    titleDelay: 1000,
                    oiPollInterval: 5000,
                    updateThrottle: 100
                },
                chart: {
                    liqSensitivity: 100,
                    pressureDecay: 0.998,
                    maxReconnectDelay: 16000
                }
            };

            // DOM Elements
            const DOM = {
                priceChart: document.getElementById('price-chart'),
                liqChart: document.getElementById('liq-chart'),
                cvdChart: document.getElementById('cvd-chart'),
                oiChart: document.getElementById('oi-chart'),
                loadingOverlay: document.getElementById('loading-overlay'),
                loadingText: document.getElementById('loading-text'),
                cvdData: document.getElementById('cvd-data'),
                oiData: document.getElementById('oi-data'),
                longLiqData: document.getElementById('long-liq-data'),
                shortLiqData: document.getElementById('short-liq-data'),
                connectionStatus: document.getElementById('connection-status')
            };

            // State Management
            const state = {
                lastBtcPrice: 0,
                cvdCumulative: 0,
                oiCumulative: 0,
                lastOiValue: null,
                longPressure: 0,
                shortPressure: 0,
                lastPressureUpdate: Date.now(),
                tradeCount: 0,
                lastLogTime: Date.now(),
                connectionStatus: { kraken: false, bybit: false, binance: false },
                charts: {},
                candles: {},
                pendingUpdates: { price: false, cvd: false, oi: false, liq: false },
                lastUpdateTime: 0,
                lastPriceTimestamp: 0 // Track the last timestamp for price series
            };

            // Utility Functions
            const utils = {
                isValidBar: (bar) => bar && ['time', 'open', 'high', 'low', 'close'].every(key => Number.isFinite(bar[key])),
                formatValue: (value) => {
                    const abs = Math.abs(value);
                    return abs >= 1e6 ? (value / 1e6).toFixed(2) + 'm' : abs >= 1e3 ? (value / 1e3).toFixed(2) + 'k' : value.toFixed(2);
                },
                formatDollar: (btcValue) => {
                    const dollarValue = Math.round((btcValue / CONFIG.chart.liqSensitivity) * state.lastBtcPrice / 1e4) * 1e4;
                    return '$' + Math.abs(dollarValue).toLocaleString('en-US', { minimumFractionDigits: 0 });
                },
                updateColor: (element, value) => {
                    element.classList.toggle('negative', value < 0);
                    element.classList.toggle('positive', value > 0 && value !== 0);
                },
                logTradeCount: () => {
                    const now = Date.now();
                    if (now - state.lastLogTime >= 60000) {
                        console.log(`Trades/min: ${(state.tradeCount / ((now - state.lastLogTime) / 60000)).toFixed(1)}`);
                        state.tradeCount = 0;
                        state.lastLogTime = now;
                    }
                },
                handleError: (msg, error) => console.error(`${msg}:`, error),
                createFallbackBar: (timestamp) => ({
                    time: Math.floor(timestamp / CONFIG.time.barInterval) * CONFIG.time.barInterval,
                    open: 0,
                    high: 0,
                    low: 0,
                    close: 0
                })
            };

            // Chart Factory
            const createChart = (element, height, title) => {
                const chart = LightweightCharts.createChart(element, {
                    width: element.offsetWidth,
                    height,
                    layout: { background: { color: '#161b22' }, textColor: '#D3D3D3', fontSize: 10 },
                    grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                    timeScale: { timeVisible: true, secondsVisible: true, borderColor: '#2A2A2A', rightOffset: 5 },
                    rightPriceScale: { borderColor: '#2A2A2A', autoScale: true, visible: !!title }
                });
                const series = chart.addCandlestickSeries({
                    upColor: '#888888', downColor: '#888888', borderColor: '#888888', wickUpColor: '#888888', wickDownColor: '#888888', title
                });
                const zeroLine = title ? null : chart.addLineSeries({ color: '#555555', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
                return { chart, series, zeroLine };
            };

            // Chart Initialization
            const initCharts = () => {
                state.charts.price = createChart(DOM.priceChart, 300, 'Price');
                state.charts.cvd = createChart(DOM.cvdChart, 100, '');
                state.charts.oi = createChart(DOM.oiChart, 100, '');
                state.charts.liq = createChart(DOM.liqChart, 100, '');
            };

            const enableChartSync = () => {
                state.charts.price.chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    const range = state.charts.price.chart.timeScale().getVisibleRange();
                    if (range && state.candles.price && state.candles.price.length > 1 && state.candles.price.every(utils.isValidBar)) {
                        console.log('Syncing time range:', range);
                        Object.keys(state.charts).forEach(key => {
                            if (key !== 'price') state.charts[key].chart.timeScale().setVisibleRange(range);
                        });
                    }
                });
            };

            // WebSocket Manager
            const webSocketManager = {
                sockets: [],
                create: (url, onOpen, onMessage, label) => {
                    const ws = new WebSocket(url);
                    let reconnectDelay = 2000;
                    ws.onopen = () => {
                        state.connectionStatus[label.toLowerCase()] = true;
                        DOM.connectionStatus.textContent = Object.values(state.connectionStatus).every(v => v) ? 'Connected' : 'Disconnected';
                        DOM.connectionStatus.classList.toggle('disconnected', !Object.values(state.connectionStatus).every(v => v));
                        onOpen(ws);
                        reconnectDelay = 2000;
                    };
                    ws.onmessage = onMessage;
                    ws.onerror = () => state.connectionStatus[label.toLowerCase()] = false;
                    ws.onclose = () => {
                        state.connectionStatus[label.toLowerCase()] = false;
                        setTimeout(() => webSocketManager.create(url, onOpen, onMessage, label), reconnectDelay);
                        reconnectDelay = Math.min(reconnectDelay * 2, CONFIG.chart.maxReconnectDelay);
                    };
                    webSocketManager.sockets.push(ws);
                    return ws;
                },
                cleanup: () => webSocketManager.sockets.forEach(ws => ws.close())
            };

            // Data Fetching
            const dataFetcher = {
                fetchHistorical: async () => {
                    const startTime = Math.floor(Date.now() / 1000) - (CONFIG.time.historyDays * 24 * 60 * 60) - 60; // Offset by 1 minute to avoid overlap
                    try {
                        DOM.loadingText.textContent = 'Fetching historical data from Kraken...';
                        console.log('Fetching historical data from Kraken...');
                        const response = await fetch(`${CONFIG.urls.krakenOhlc}?pair=XBTUSD&interval=1&since=${startTime}`);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();
                        console.log('Kraken API response:', JSON.stringify(data));

                        if (data.error && data.error.length) throw new Error(`Kraken API error: ${data.error}`);
                        const bars = data.result && data.result['XXBTZUSD'];
                        if (!bars || !Array.isArray(bars) || bars.length === 0) {
                            console.warn('No valid XXBTZUSD data in Kraken response, using fallback');
                            state.candles.price = [utils.createFallbackBar(Date.now() / 1000)];
                        } else {
                            DOM.loadingText.textContent = 'Processing historical data...';
                            const historicalData = [];
                            for (let i = 0; i < bars.length; i++) {
                                const [time, openStr, highStr, lowStr, closeStr] = bars[i];
                                const timeNum = parseInt(time, 10);
                                const open = parseFloat(openStr);
                                const high = parseFloat(highStr);
                                const low = parseFloat(lowStr);
                                const close = parseFloat(closeStr);
                                const nextClose = i + 1 < bars.length ? parseFloat(bars[i + 1][4]) : close;

                                if (!Number.isFinite(timeNum) || !Number.isFinite(open) || !Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close)) {
                                    console.warn(`Invalid bar at index ${i}:`, bars[i]);
                                    continue;
                                }

                                historicalData.push({
                                    time: timeNum,
                                    open,
                                    high: Math.max(open, high),
                                    low: Math.min(open, low),
                                    close: (open + close) / 2
                                });
                                historicalData.push({
                                    time: timeNum + CONFIG.time.barInterval,
                                    open: (open + close) / 2,
                                    high: Math.max(high, close, nextClose),
                                    low: Math.min(low, close),
                                    close
                                });
                            }
                            console.log('Processed historical data before filter:', historicalData);
                            state.candles.price = historicalData.filter(utils.isValidBar).slice(-CONFIG.time.maxBars);
                            if (state.candles.price.length === 0) {
                                console.warn('No valid bars after filtering, using fallback');
                                state.candles.price = [utils.createFallbackBar(Date.now() / 1000)];
                            }
                            console.log('Filtered historical data:', state.candles.price);
                            state.lastPriceTimestamp = state.candles.price[state.candles.price.length - 1].time;
                        }

                        state.lastBtcPrice = state.candles.price[state.candles.price.length - 1].close || 0;
                        if (state.candles.price.length > 0 && state.candles.price.every(utils.isValidBar)) {
                            DOM.loadingText.textContent = 'Setting chart data...';
                            console.log('Setting price data to chart...');
                            state.charts.price.series.setData(state.candles.price);
                            console.log('Price data set successfully');
                        } else {
                            throw new Error('Invalid or empty price data after processing');
                        }

                        DOM.loadingText.textContent = 'Initializing secondary charts...';
                        state.candles.liq = state.candles.price.map(bar => ({ ...bar, open: 0, high: 0, low: 0, close: 0 }));
                        state.candles.cvd = state.candles.price.map(bar => ({ ...bar, open: 0, high: 0, low: 0, close: 0 }));
                        state.candles.liqCurrent = { ...state.candles.liq[state.candles.liq.length - 1] };
                        state.candles.cvdCurrent = { ...state.candles.cvd[state.candles.cvd.length - 1] };

                        await Promise.all([
                            state.charts.liq.series.setData(state.candles.liq),
                            state.charts.liq.zeroLine.setData(state.candles.price.map(bar => ({ time: bar.time, value: 0 }))),
                            state.charts.cvd.series.setData(state.candles.cvd),
                            state.charts.cvd.zeroLine.setData(state.candles.price.map(bar => ({ time: bar.time, value: 0 })))
                        ]);

                        DOM.loadingText.textContent = 'Fetching open interest...';
                        await dataFetcher.fetchInitialOi();
                        state.candles.priceCurrent = { ...state.candles.price[state.candles.price.length - 1] };

                        if (state.candles.price.length > 1) {
                            DOM.loadingText.textContent = 'Scrolling to real-time...';
                            console.log('Scrolling to real-time...');
                            setTimeout(() => {
                                state.charts.price.chart.timeScale().scrollToRealTime();
                                console.log('Scrolled to real-time');
                            }, 100);
                        }
                        console.log('Historical data set:', state.candles.price);

                        enableChartSync();
                        return true;
                    } catch (error) {
                        utils.handleError('Historical fetch failed', error);
                        state.connectionStatus.kraken = false;
                        state.candles.price = [utils.createFallbackBar(Date.now() / 1000)];
                        state.lastBtcPrice = 0;
                        state.lastPriceTimestamp = state.candles.price[0].time;
                        state.charts.price.series.setData(state.candles.price);

                        state.candles.liq = state.candles.price.map(bar => ({ ...bar, open: 0, high: 0, low: 0, close: 0 }));
                        state.candles.cvd = state.candles.price.map(bar => ({ ...bar, open: 0, high: 0, low: 0, close: 0 }));
                        await Promise.all([
                            state.charts.liq.series.setData(state.candles.liq),
                            state.charts.liq.zeroLine.setData(state.candles.price.map(bar => ({ time: bar.time, value: 0 }))),
                            state.charts.cvd.series.setData(state.candles.cvd),
                            state.charts.cvd.zeroLine.setData(state.candles.price.map(bar => ({ time: bar.time, value: 0 })))
                        ]);
                        state.candles.liqCurrent = { ...state.candles.liq[0] };
                        state.candles.cvdCurrent = { ...state.candles.cvd[0] };

                        state.candles.priceCurrent = { ...state.candles.price[0] };
                        await dataFetcher.fetchInitialOi();
                        console.log('Fallback data set:', state.candles.price);

                        enableChartSync();
                        return false;
                    }
                },
                fetchInitialOi: async () => {
                    try {
                        console.log('Fetching initial OI from Binance...');
                        const response = await fetch(`${CONFIG.urls.binanceOi}?symbol=BTCUSDT`);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();
                        console.log('Binance OI response:', JSON.stringify(data));
                        const value = parseFloat(data.openInterest);
                        if (!Number.isFinite(value)) {
                            console.warn('Invalid OI value, skipping');
                            return;
                        }

                        state.lastOiValue = value;
                        state.candles.oi = state.candles.price.map(bar => ({ time: bar.time, open: state.oiCumulative, high: state.oiCumulative, low: state.oiCumulative, close: state.oiCumulative }));
                        await Promise.all([
                            state.charts.oi.series.setData(state.candles.oi),
                            state.charts.oi.zeroLine.setData(state.candles.price.map(bar => ({ time: bar.time, value: 0 })))
                        ]);
                        const barTime = Math.floor(Date.now() / 1000 / CONFIG.time.barInterval) * CONFIG.time.barInterval;
                        state.candles.oiCurrent = { time: barTime, open: state.oiCumulative, high: state.oiCumulative, low: state.oiCumulative, close: state.oiCumulative };
                        DOM.oiData.textContent = utils.formatDollar(state.oiCumulative);
                        utils.updateColor(DOM.oiData, state.oiCumulative);
                        state.connectionStatus.binance = true;
                    } catch (error) {
                        utils.handleError('Initial OI fetch failed', error);
                        state.connectionStatus.binance = false;
                    }
                },
                fetchLiveOi: async () => {
                    try {
                        const response = await fetch(`${CONFIG.urls.binanceOi}?symbol=BTCUSDT`);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();
                        const value = parseFloat(data.openInterest);
                        if (Number.isFinite(value)) updateCandle('oi', Math.floor(Date.now() / 1000), value);
                    } catch (error) {
                        state.connectionStatus.binance = false;
                    }
                }
            };

            // Update Handler
            const updateCandle = (type, timestamp, value, side) => {
                const barTime = Math.floor(timestamp / CONFIG.time.barInterval) * CONFIG.time.barInterval;
                let current = state.candles[`${type}Current`];
                let data = state.candles[type];
                let series = state.charts[type].series;

                if (type === 'price') {
                    if (barTime <= state.lastPriceTimestamp) {
                        console.log(`Skipping price update: ${barTime} <= ${state.lastPriceTimestamp}`);
                        return; // Skip updates with timestamps not strictly greater than the last bar
                    }
                    if (!current || current.time !== barTime) {
                        if (current && utils.isValidBar(current)) {
                            data.push(current);
                            if (data.length > CONFIG.time.maxBars) data.shift();
                        }
                        current = { time: barTime, open: value, high: value, low: value, close: value };
                    } else {
                        current.high = Math.max(current.high, value);
                        current.low = Math.min(current.low, value);
                        current.close = value;
                    }
                    state.lastBtcPrice = current.close;
                    state.tradeCount++;
                    state.lastPriceTimestamp = barTime; // Update last timestamp
                    utils.logTradeCount();
                } else if (type === 'cvd') {
                    if (!current || current.time !== barTime) {
                        if (!current) {
                            current = { time: barTime, open: 0, high: 0, low: 0, close: 0 };
                            data = [current];
                            series.setData(data);
                        } else if (utils.isValidBar(current)) {
                            data.push(current);
                            if (data.length > CONFIG.time.maxBars) data.shift();
                        }
                        current = { time: barTime, open: state.cvdCumulative, high: state.cvdCumulative, low: state.cvdCumulative, close: state.cvdCumulative };
                    }
                    state.cvdCumulative += value;
                    current.high = Math.max(current.high, state.cvdCumulative);
                    current.low = Math.min(current.low, state.cvdCumulative);
                    current.close = state.cvdCumulative;
                } else if (type === 'oi') {
                    if (state.lastOiValue !== null) state.oiCumulative += value - state.lastOiValue;
                    state.lastOiValue = value;
                    if (!current || current.time !== barTime) {
                        if (current && utils.isValidBar(current)) {
                            data.push(current);
                            if (data.length > CONFIG.time.maxBars) data.shift();
                        }
                        current = { time: barTime, open: state.oiCumulative, high: state.oiCumulative, low: state.oiCumulative, close: state.oiCumulative };
                    } else {
                        current.high = Math.max(current.high, state.oiCumulative);
                        current.low = Math.min(current.low, state.oiCumulative);
                        current.close = state.oiCumulative;
                    }
                } else if (type === 'liq') {
                    const now = Date.now();
                    const timeElapsed = (now - state.lastPressureUpdate) / 30000;
                    state.lastPressureUpdate = now;
                    state.longPressure *= Math.pow(CONFIG.chart.pressureDecay, timeElapsed);
                    state.shortPressure *= Math.pow(CONFIG.chart.pressureDecay, timeElapsed);
                    const delta = value * CONFIG.chart.liqSensitivity;
                    if (side === 'Buy') state.longPressure += delta;
                    else if (side === 'Sell') state.shortPressure += delta;

                    if (!current || current.time !== barTime) {
                        if (current && utils.isValidBar(current)) {
                            data.push(current);
                            if (data.length > CONFIG.time.maxBars) data.shift();
                        }
                        const net = state.longPressure - state.shortPressure;
                        current = { time: barTime, open: net, high: net, low: net, close: net };
                    }
                    const netPressure = state.longPressure - state.shortPressure;
                    current.high = Math.max(current.high, netPressure);
                    current.low = Math.min(current.low, netPressure);
                    current.close = netPressure;
                }

                state.candles[`${type}Current`] = current;
                state.candles[type] = data;
                state.pendingUpdates[type] = true;
                requestAnimationFrame(throttleUpdates);
            };

            const throttleUpdates = () => {
                const now = performance.now();
                if (now - state.lastUpdateTime < CONFIG.time.updateThrottle) return;
                state.lastUpdateTime = now;

                if (state.pendingUpdates.price && utils.isValidBar(state.candles.priceCurrent)) {
                    state.charts.price.series.update(state.candles.priceCurrent);
                    setTimeout(() => document.title = `BTC: $${state.lastBtcPrice.toFixed(2)}`, CONFIG.time.titleDelay);
                }
                if (state.pendingUpdates.cvd && utils.isValidBar(state.candles.cvdCurrent)) {
                    state.charts.cvd.series.update(state.candles.cvdCurrent);
                    DOM.cvdData.textContent = utils.formatDollar(state.cvdCumulative);
                    utils.updateColor(DOM.cvdData, state.cvdCumulative);
                }
                if (state.pendingUpdates.oi && utils.isValidBar(state.candles.oiCurrent)) {
                    state.charts.oi.series.update(state.candles.oiCurrent);
                    DOM.oiData.textContent = utils.formatDollar(state.oiCumulative);
                    utils.updateColor(DOM.oiData, state.oiCumulative);
                }
                if (state.pendingUpdates.liq && utils.isValidBar(state.candles.liqCurrent)) {
                    state.charts.liq.series.update(state.candles.liqCurrent);
                    DOM.longLiqData.textContent = utils.formatDollar(state.longPressure);
                    DOM.shortLiqData.textContent = utils.formatDollar(state.shortPressure);
                }

                state.pendingUpdates = { price: false, cvd: false, oi: false, liq: false };
            };

            // Main Execution
            initCharts();

            const krakenWs = webSocketManager.create(
                CONFIG.urls.krakenWs,
                ws => ws.send(JSON.stringify({ event: 'subscribe', pair: ['XBT/USD'], subscription: { name: 'trade' } })),
                event => {
                    try {
                        const data = JSON.parse(event.data);
                        if (!Array.isArray(data) || data[2] !== 'trade') return;
                        const trade = data[1][0];
                        const price = parseFloat(trade[0]);
                        const timestamp = Math.floor(parseFloat(trade[2]));
                        if (Number.isFinite(price) && Number.isFinite(timestamp)) updateCandle('price', timestamp, price);
                    } catch (error) {
                        utils.handleError('Kraken WS error', error);
                    }
                },
                'Kraken'
            );

            const bybitWs = webSocketManager.create(
                CONFIG.urls.bybitWs,
                ws => ws.send(JSON.stringify({ op: 'subscribe', args: ['publicTrade.BTCUSDT', 'liquidation.BTCUSDT'] })),
                event => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.topic === 'liquidation.BTCUSDT' && data.data) {
                            const { ts, size, qty, side } = data.data;
                            const timestamp = Math.floor(parseInt(ts) / 1000);
                            const liqValue = parseFloat(size || qty || 0);
                            if (Number.isFinite(timestamp) && Number.isFinite(liqValue) && side) updateCandle('liq', timestamp, liqValue, side);
                        } else if (data.topic === 'publicTrade.BTCUSDT' && data.data) {
                            const trade = data.data[0];
                            const volume = parseFloat(trade.v);
                            const side = trade.S === 'Buy' ? 1 : -1;
                            const timestamp = Math.floor(parseInt(trade.T) / 1000);
                            if (Number.isFinite(volume) && Number.isFinite(timestamp)) updateCandle('cvd', timestamp, volume * side);
                        }
                    } catch (error) {
                        utils.handleError('Bybit WS error', error);
                    }
                },
                'Bybit'
            );

            const success = await dataFetcher.fetchHistorical();
            if (!success) {
                document.title = 'BTC: $0.00';
            }

            DOM.cvdData.textContent = utils.formatDollar(state.cvdCumulative);
            DOM.longLiqData.textContent = utils.formatDollar(state.longPressure);
            DOM.shortLiqData.textContent = utils.formatDollar(state.shortPressure);

            const oiInterval = setInterval(dataFetcher.fetchLiveOi, CONFIG.time.oiPollInterval);
            DOM.loadingOverlay.style.display = 'none';
            setTimeout(() => DOM.connectionStatus.textContent = Object.values(state.connectionStatus).every(v => v) ? 'Connected' : 'Disconnected', 5000);

            window.addEventListener('beforeunload', () => {
                webSocketManager.cleanup();
                clearInterval(oiInterval);
            });
        })();
    </script>
</body>
</html>
