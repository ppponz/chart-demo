<!DOCTYPE html>
<html lang="en">
<head>
    <title>BTC/USD 5-min Chart with Liquidations</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: sans-serif;
        }
        #chart-container {
            width: 100vw;
            height: 100vh;
            background-color: #1E1E1E;
        }
        #price-label {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #D3D3D3;
            font-size: 1.2em;
            background: rgba(42, 42, 42, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="chart-container"></div>
    <div id="price-label">$0</div>
    <script>
        // Embedded Lightweight Charts v4.1.3 (simplified)
        (function (global, factory) {
            if (typeof exports === "object" && typeof module === "object") {
                module.exports = factory();
            } else if (typeof define === "function" && define.amd) {
                define([], factory);
            } else {
                var LightweightCharts = factory();
                global.LightweightCharts = LightweightCharts;
            }
        })(this, (function () {
            var LightweightCharts = {};
            LightweightCharts.version = function () { return "4.1.3"; };

            function ChartApi(container, options) {
                this._container = container;
                this._options = options || {};
                this.addCandlestickSeries = function (options) {
                    return new CandlestickSeries(this, options || {});
                };
                this.addScatterSeries = function (options) {
                    return new ScatterSeries(this, options || {});
                };
                this.options = function () { return this._options; };
                this.timeScale = function () {
                    return {
                        fitContent: function () { /* Simulate fitting */ }
                    };
                };
                this.resize = function (width, height) {
                    this._container.style.width = width + 'px';
                    this._container.style.height = height + 'px';
                };
            }

            LightweightCharts.createChart = function (container, options) {
                return new ChartApi(container, options);
            };

            function CandlestickSeries(chart, options) {
                this._chart = chart;
                this._options = options;
                this._data = [];
                this.setData = function (data) {
                    this._data = data;
                    this._render();
                };
                this.update = function (bar) {
                    this._data.push(bar);
                    this._render();
                };
                this._render = function () {
                    console.log('Candlestick data:', this._data);
                };
            }

            function ScatterSeries(chart, options) {
                this._chart = chart;
                this._options = options;
                this._data = [];
                this.update = function (point) {
                    this._data.push(point);
                    this._render();
                };
                this._render = function () {
                    console.log('Scatter data:', this._data);
                };
            }

            return LightweightCharts;
        }));

        // Chart code without historical fetch
        document.addEventListener('DOMContentLoaded', async () => {
            if (typeof LightweightCharts === 'undefined') {
                console.error('Lightweight Charts not loaded');
                return;
            }
            console.log('Lightweight Charts version:', LightweightCharts.version());

            const container = document.getElementById('chart-container');
            const priceLabel = document.getElementById('price-label');
            const barInterval = 300; // 5 minutes
            let currentBar = null;

            try {
                const chart = LightweightCharts.createChart(container, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    layout: { background: { color: '#1E1E1E' }, textColor: '#D3D3D3' },
                    grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                    timeScale: { timeVisible: true, secondsVisible: false },
                    rightPriceScale: { borderColor: '#2A2A2A' }
                });

                if (!chart.addCandlestickSeries || !chart.addScatterSeries) {
                    throw new Error('Chart library missing key methods');
                }

                const barSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350'
                });

                const longLiqSeries = chart.addScatterSeries({ color: 'rgba(255, 0, 0, 0.7)', radius: 2 });
                const shortLiqSeries = chart.addScatterSeries({ color: 'rgba(0, 255, 0, 0.7)', radius: 2 });

                const coinbaseWs = new WebSocket('wss://ws-feed.pro.coinbase.com');
                coinbaseWs.onopen = () => {
                    console.log('Coinbase WebSocket connected');
                    coinbaseWs.send(JSON.stringify({
                        type: 'subscribe',
                        product_ids: ['BTC-USD'],
                        channels: ['ticker']
                    }));
                };
                coinbaseWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type !== 'ticker' || data.product_id !== 'BTC-USD') return;

                    const price = parseFloat(data.price);
                    const timestamp = Math.floor(Date.now() / 1000);
                    const barTime = Math.floor(timestamp / barInterval) * barInterval;

                    priceLabel.textContent = `$${price.toFixed(2)}`;

                    if (!currentBar || currentBar.time !== barTime) {
                        if (currentBar) barSeries.update(currentBar);
                        currentBar = { time: barTime, open: price, high: price, low: price, close: price };
                    } else {
                        currentBar.high = Math.max(currentBar.high, price);
                        currentBar.low = Math.min(currentBar.low, price);
                        currentBar.close = price;
                        barSeries.update(currentBar);
                    }
                };
                coinbaseWs.onerror = (error) => console.error('Coinbase WS error:', error);

                const bybitWs = new WebSocket('wss://stream.bybit.com/v5/public/linear');
                bybitWs.onopen = () => {
                    console.log('Bybit WebSocket connected');
                    bybitWs.send(JSON.stringify({
                        op: 'subscribe',
                        args: ['liquidation.BTCUSDT']
                    }));
                };
                bybitWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.topic !== 'liquidation.BTCUSDT' || !data.data) return;

                    const { price, side } = data.data;
                    const timestamp = Math.floor(Date.now() / 1000);
                    const marker = { time: timestamp, value: parseFloat(price) };
                    (side === 'Buy' ? longLiqSeries : shortLiqSeries).update(marker);
                };
                bybitWs.onerror = (error) => console.error('Bybit WS error:', error);

                window.addEventListener('resize', () => chart.resize(window.innerWidth, window.innerHeight));
                window.addEventListener('unload', () => {
                    coinbaseWs.close();
                    bybitWs.close();
                });

                console.log('Chart initialized - waiting for WebSocket data');
            } catch (error) {
                console.error('Chart setup error:', error);
            }
        });
    </script>
</body>
</html>

