<!DOCTYPE html>
<html lang="en">
<head>
    <title>Coinbase BTC/USD 30-Second Bars (Max History)</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { margin: 0; }
        #chart-container { width: 100%; height: 100vh; }
    </style>
</head>
<body>
    <div id="chart-container"></div>
    <script>
        window.onload = async function() {
            console.log('Window loaded');

            if (typeof LightweightCharts === 'undefined') {
                console.error('LightweightCharts failed to load');
                return;
            }
            console.log('LightweightCharts loaded');

            const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
                width: window.innerWidth,
                height: window.innerHeight,
                layout: { background: { color: '#1E1E1E' }, textColor: '#D3D3D3' }, // Grok-like background and text
                grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                timeScale: { timeVisible: true, secondsVisible: true }
            });
            console.log('Chart created');

            const barSeries = chart.addBarSeries({ color: '#2962FF' });
            console.log('Bar series created');

            let currentBar = null;
            const barInterval = 30; // 30 seconds
            const barsPerCall = 2000; // Max per request
            let allBars = [];

            async function fetchHistorical(segment) {
                const now = Math.floor(Date.now() / 1000);
                const toTs = now - (segment * barsPerCall * barInterval);
                const url = `https://min-api.cryptocompare.com/data/v2/histominute?fsym=BTC&tsym=USD&limit=${barsPerCall}&aggregate=0.5&toTs=${toTs}`;
                console.log('Fetching segment:', segment, 'toTs:', toTs);
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Fetch failed');
                    const data = await response.json();
                    if (!data.Data || !data.Data.Data) throw new Error('No data returned');
                    const bars = data.Data.Data.map(item => ({
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close
                    }));
                    return bars;
                } catch (error) {
                    console.error('Segment', segment, 'error:', error);
                    return [];
                }
            }

            for (let i = 0; i < 5; i++) { // 5 calls = ~10,000 bars
                const bars = await fetchHistorical(i);
                allBars = allBars.concat(bars);
            }
            allBars.sort((a, b) => a.time - b.time);
            barSeries.setData(allBars);
            console.log('Historical data loaded:', allBars.length, 'bars');
            chart.timeScale().fitContent();

            const socket = new WebSocket('wss://ws-feed.exchange.coinbase.com');
            socket.onopen = () => {
                console.log('WebSocket connected');
                socket.send(JSON.stringify({
                    type: 'subscribe',
                    product_ids: ['BTC-USD'],
                    channels: ['ticker']
                }));
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type !== 'ticker' || data.product_id !== 'BTC-USD') return;

                const price = parseFloat(data.price);
                const timestamp = Math.floor(Date.now() / 1000);
                const barTime = Math.floor(timestamp / barInterval) * barInterval;

                if (!currentBar || currentBar.time !== barTime) {
                    if (currentBar) {
                        barSeries.update(currentBar);
                        console.log('Bar completed:', currentBar);
                    }
                    currentBar = {
                        time: barTime,
                        open: price,
                        high: price,
                        low: price,
                        close: price
                    };
                    console.log('New bar:', currentBar);
                } else {
                    currentBar.high = Math.max(currentBar.high, price);
                    currentBar.low = Math.min(currentBar.low, price);
                    currentBar.close = price;
                    barSeries.update(currentBar);
                }

                chart.timeScale().scrollToRealTime();
            };

            socket.onerror = (error) => console.error('WebSocket error:', error);
            socket.onclose = () => console.log('WebSocket closed');

            window.addEventListener('resize', () => {
                chart.resize(window.innerWidth, window.innerHeight);
            });
        };
    </script>
</body>
</html>
